---
title: "Differential expression analysis"
author: "Scott Campit"
output: 
  html_notebook:
    toc: yes
---

## Summary
This notebook performs differential expression analysis for various transcriptomics datasets. 

**UPDATES: **

  * November 4, 2020: Added more stringent and robust differential expression analysis options.
  * Follow computational pipeline outlined in Yu, et al. (2019). Comprehensive transcriptomic analysis of cell lines as models of primary tumors across 22 tumor types. Nature communications, 10(1), 1-11.
  * Compute differentially expressed genes using both edgeR, DESeq2, and limma-voom
  * Take intersection of differentially expressed genes 
  
## 1. Load libraries
First we'll load some essential packages needed to run differential expression analysis.
```{r, warning=FALSE, message=FALSE}
# Bioinformatics libraries
#install.packages("BiocManager")
#BiocManager::install(c("BiocManager", "edgeR", 
#                   "DESeq2", "limma", 
#                   "sva", "PCAtools"))

#install.packages("CePa", dependences=TRUE)
#BiocManager::install("Rgraphviz")
library(CePa)
library(edgeR)
library(DESeq2)
library(limma)
library(sva)
library(PCAtools)

# Data science libraries
#install.packages(c("tidyverse", "readr", "rrcov"))
library(tidyverse)
library(readr)
library(rrcov)

```

## 2. Perform data preprocessing

This code block performs essential data preprocessing for the cancer cell line encyclopedia data.

### Read in raw RNASeq counts

First, let's load the table with the raw RNASeq gene counts.
```{r}
# ACLX path
#readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"
#readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_RNAseq_genes_counts_20180929.gct"

# Dell
#readpath = "D:\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"

# Load data either as a TPM or gene counts. I'm doing this from scratch.
#ccle = read_delim(file=readpath, delim='\t')

# Linux
readpath = "CCLE_RNAseq_genes_counts_20180929.gct"
ccle = read.gct(readpath)
```

Note that in the raw gene count data matrix, the rows are labeled by Ensembl IDs, while the columns have the syntax CELLLINE_TISSUE, separated by an underscore. I can keep the Ensembl gene IDs, but I need to extract the tissue type, as this is a covariate of interest.

Later on, I can add other covariates of interest using meta data from the CCLE.

### Aggregate duplicate cell line entries.
Note that some cell lines (columns) are duplicate entries. I need to aggregate them before moving on to additional preprocessing steps. 
```{r}
tmp = t(ccle)
agg_tmp = aggregate(tmp, by=list(rownames(tmp)), mean)
agg_tmp[, 2:length(agg_tmp)] = lapply(agg_tmp[, 2:length(agg_tmp)], as.integer)
agg_tmp = as.data.frame(agg_tmp)

# Get final aggregated matrix
ccle = t(agg_tmp)
ccle = as.data.frame(ccle)
names(ccle) = lapply(ccle[1, ], as.character)
ccle = ccle[-1, ]
```

Now that I have aggregated duplicate cell lines, I can construct the phenotype dataframe `pheno` that I will need for downstream data processing.

### Construct the `pheno` dataframe
First, we'll extract the name of the tumor tissue subtype and then store the data in a dataframe. 

```{r}
# Get data from the ccle dataframe
tmp = colnames(ccle)
tissue = word(string=tmp, start=2, end=-1, sep="_")
ccl = word(string=tmp, start=1, sep="_")

# Store into dataframe
colnames(ccle) = as.character(ccl)
```

Now let's construct the `pheno` dataframe. This will be used to create the model and the null model when performing covariate and artifact correction.
```{r}
# Create a dataframe with phenotype data
ccle = ccle[, -duplicated(ccl)]
tissue = tissue[-duplicated(ccl)]
ccl = ccl[-duplicated(ccl)]

ccle = ccle[, -956]
tissue = tissue[-956]
ccl = ccl[-956]
pheno = data.frame("Tissue"=tissue)
row.names(pheno) = ccl
```

### Missing value imputation
Note that there are missing values, so we'll impute them with the minimum value in the dataset.
```{r}
min_impute = function(df){
  for (cols in colnames(df)) {
    if (cols %in% names(df[,sapply(df, is.numeric)])) {
      df = df %>% mutate(!!cols := replace(!!rlang::sym(cols),
                                           is.na(!!rlang::sym(cols)),
                                           min(!!rlang::sym(cols), na.rm=TRUE)))
    }
  }
  return(df)
}

ccle = min_impute(ccle)
```

Check for NaNs. It looks like there are none
```{r}
print(cat("Number of NaNs: ", sum(is.na(ccle))))

ensemble_ids = rownames(ccle)
data = data.matrix(ccle)
```

### Remove outliers
We will first remove some outliers using Robust PCA. It combines two ideas to find outliers:
  1. Find projections with maximal dispersion using a grid search.
  2. Estimate the covariance using an idea similar to Hubert robust regression.

The publication that benchmarks several robust PCA algorithms and the classical PCA counterparts can be found here: Chen, X., Zhang, B., Wang, T., Bonni, A., & Zhao, G. (2020). Robust principal component analysis for accurate outlier sample detection in RNA-Seq data. BMC bioinformatics, 21(1), 1-20.

First let's compute PCs and visualize the data with classical PCA. There are totally some really bad data points and heteroskedasticity. 
```{r}
pc = PCAtools::pca(data)
PCAtools::screeplot(pc)
PCAtools::biplot(pc)
PCAtools::pairsplot(pc)
```

Then let's get the highly quality data we want with robust PCA
```{r}
# Generate a Robust Huber object
pc = PcaHubert(data)

# Get the outliers
Xfinal = data
Xfinal = Xfinal[pc@flag, ]
genes_filtered = ensemble_ids[pc@flag]
```

### Save the Principle Component Results
I should really save this variable, because it is pretty time consuming to generate this.
```{r}
# ACLX
savepath = "C:\\Users\\scott\\Analysis\\eGEM\\r\\PCA\\CCLE_Counts_rPCA.rds"
saveRDS(pc, savepath)
```

If we want to do a final sanity check, here's a code block that can make those plots.
```{r}
pc = PCAtools::pca(data.matrix(Xfinal))
PCAtools::screeplot(pc)
PCAtools::biplot(pc)
PCAtools::pairsplot(pc)
```

### Data Normalization 
Now let's take the log2 of the counts-per-million of the RNASeq counts.
```{r}
Xfinal = DGEList(Xfinal, 
               genes=genes_filtered,
               group=as.factor(tissue))
Xnorm = calcNormFactors(Xfinal)

#cutoff = 1
#drop = which(apply(cpm(Xnorm), 1, max) < cutoff)
#Xfilter = Xnorm[-drop, ] 
#dim(Xfilter) # number of genes left

Xcpm = log2(cpm(Xnorm)+1)
```

### Batch Effect Correction using `ComBat`
Now we can use Combat to perform batch correction for multiple tissues with the cleaned up dataset.

First let's construct the model matrix which contains the adjustment variables and the variable of interest.
```{r}
mod = model.matrix(~as.factor(tissue), data=pheno)
mod0 = model.matrix(~1, data=pheno)
```

Now let's compute the latent factors that need to be estimated. Note that this code will take awhile as it needs to perform several SVD operations.
```{r}
n.sv = num.sv(dat=Xcpm, mod=mod)
svobj = svaseq(Xcpm, mod, mod0, n.sv=n.sv)
```

We can actually get differentially expressed genes using a parametric F-test. Let's check this out!
```{r}
# Compute initial P and Q-values
tmp_pval = f.pvalue(data.matrix(Xfinal), mod, mod0)
tmp_qval = p.adjust(tmp_pval, method='BH')

# Create adjusted models
modSv = cbind(mod, svobj$sv)
mod0Sv = cbind(mod0, svobj$sv)

# Adjust p-values using Combat
combat_pvalues = f.pvalue(data.matrix(Xfinal), modSv, mod0Sv)
combat_qvalues = p.adjust(combat_pvalues, method='BH')
```

### Perform *limma-voom* 
We'll save the results as an .rds file.
```{r}
# Construct an object for limma-voom
X = DGEList(counts=Xfinal, 
            genes=genes_filtered, 
            group=as.factor(tissue))
```

First, we'll need to calculate the variance weights using the voom function.
```{r}
y = voom(X, mod, plot=TRUE)
```

Okay, it looks like the variance stabilizes. Now let's fit the linear model using weighted least squares for each gene to compute some coefficients.

```{r}
design = model.matrix(~ adjvar)
theta = lmFit(object=y, design=design)
```

Now I need to estimate the contrast for each gene across different cell lines and smooth the standard errors using Empirical Bayes.
```{r}
for(i in ){
  
}
```

I can then extract differentially expressed genes
```{r}
DEG = topTable(tmp, sort.by="P", n=Inf)

```