---
title: "Differential expression analysis"
author: "Scott Campit"
output: 
  html_notebook:
    toc: yes
---

## Summary
This notebook performs differential expression analysis for various transcriptomics datasets. 

**UPDATES: **

  * November 4, 2020: Added more stringent and robust differential expression analysis options.
  * Follow computational pipeline outlined in Yu, et al. (2019). Comprehensive transcriptomic analysis of cell lines as models of primary tumors across 22 tumor types. Nature communications, 10(1), 1-11.
  * Compute differentially expressed genes using both edgeR, DESeq2, and limma-voom
  * Take intersection of differentially expressed genes 
  
## 1. Load libraries
First we'll load some essential packages needed to run differential expression analysis.
```{r, warning=FALSE, message=FALSE}
# Bioinformatics libraries
#install.packages("BiocManager")
#BiocManager::install(c("BiocManager", "edgeR", 
#                   "DESeq2", "limma", 
#                   "sva", "PCAtools"))

#install.packages("CePa", dependences=TRUE)
#BiocManager::install("Rgraphviz")
library(CePa)
library(edgeR)
library(DESeq2)
library(limma)
library(sva)
library(PCAtools)

# Data science libraries
#install.packages(c("tidyverse", "readr", "rrcov"))
library(tidyverse)
library(readr)
library(rrcov)
```

## 2. Perform data preprocessing

This code block performs essential data preprocessing for the cancer cell line encyclopedia data.

### Read in raw RNASeq counts

First, let's load the table with the raw RNASeq gene counts.
```{r}
# ACLX path
#readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"
#readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_RNAseq_genes_counts_20180929.gct"

# Dell
#readpath = "D:\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"

# Load data either as a TPM or gene counts. I'm doing this from scratch.
#ccle = read_delim(file=readpath, delim='\t')

# Linux
readpath = "~/Data/RNASeq/CCLE/CCLE_RNAseq_genes_counts_20180929.gct"
ccle = read.gct(readpath)
```

Note that in the raw gene count data matrix, the rows are labeled by Ensembl IDs, while the columns have the syntax CELLLINE_TISSUE, separated by an underscore. I can keep the Ensembl gene IDs, but I need to extract the tissue type, as this is a covariate of interest.

### Aggregate and remove duplicate cell line entries.
Note that some cell lines (columns) are duplicate entries. I need to aggregate them before moving on to additional preprocessing steps. 
```{r}
tmp = t(ccle)
agg_tmp = aggregate(tmp, by=list(rownames(tmp)), mean)
agg_tmp[, 2:length(agg_tmp)] = lapply(agg_tmp[, 2:length(agg_tmp)], as.integer)
agg_tmp = as.data.frame(agg_tmp)

# Get final aggregated matrix
ccle = t(agg_tmp)
ccle = as.data.frame(ccle)
names(ccle) = lapply(ccle[1, ], as.character)
ccle = ccle[-1, ]
```

Now let's begin preprocessing by grabbing some important meta data, specifically the tissue names.
```{r}
# Get data from the ccle dataframe
tmp = colnames(ccle)
tissue = word(string=tmp, start=2, end=-1, sep="_")
ccl = word(string=tmp, start=1, sep="_")

# Store into dataframe
colnames(ccle) = as.character(ccl)
```

There seems to be a persistent duplicate that I can't get rid of from the aggregation step. Thus, I performed it manually.
```{r}
ccle = ccle[, -duplicated(ccl)]
tissue = tissue[-duplicated(ccl)]
ccl = ccl[-duplicated(ccl)]

ccle = ccle[, -956]
tissue = tissue[-956]
ccl = ccl[-956]
```

### Missing value imputation
Note that there are missing values, so we'll impute them with the minimum value in the dataset.
```{r}
min_impute = function(df){
  for (cols in colnames(df)) {
    if (cols %in% names(df[,sapply(df, is.numeric)])) {
      df = df %>% mutate(!!cols := replace(!!rlang::sym(cols),
                                           is.na(!!rlang::sym(cols)),
                                           min(!!rlang::sym(cols), na.rm=TRUE)))
    }
  }
  return(df)
}

ccle = min_impute(ccle)
```

Check for NaNs. It looks like there are none
```{r}
print(cat("Number of NaNs: ", sum(is.na(ccle))))

ensemble_ids = rownames(ccle)
```

### Separate solid tumor and hematopoietic cancer cell lines
I need to separate the hematopoeitic and leukemia cell line lineages. Then I can perform differential expression analysis on both of the them separately.
```{r}
HL_idx = (tissue == "HAEMATOPOIETIC_AND_LYMPHOID_TISSUE")
HL_CCL = ccle[ , c(HL_idx)]
HL_tissue = tissue[c(HL_idx)]
SOLID_CCL = ccle[ , !c(HL_idx)]
SOLID_tissue = tissue[!c(HL_idx)]
```

### Remove outliers
We will first remove some outliers in both the HL and SOLID datasets using Robust PCA. It combines two ideas to find outliers:
  1. Find projections with maximal dispersion using a grid search.
  2. Estimate the covariance using an idea similar to Hubert robust regression.

First, we'll define a function to do this filtering.
```{r}
# Create a function that filters data using ROBPCA
removeOutliers = function(data, id){
  pca_obj = PcaHubert(data)
  filtered_data = data[pca_obj@flag, ]
  filtered_id = id[pca_obj@flag]
  outlier_data = data[!pca_obj@flag, ]
  outlier_id = id[!pca_obj@flag]
  
  setClass(Class="geneObj",
           representation(
             data="matrix",
             outlier_data="matrix",
             id="character",
             outlier_id="character"
           )
   )
   return(new("geneObj",
          data=filtered_data,
          outlier_data=outlier_data,
          id=filtered_id,
          outlier_id=outlier_id))
}
```

Now let's do this filtering for both genes and cell lines.
```{r}
# Construct the input for PcaHubert of class matrix
HL_data = data.matrix(HL_CCL)
SOLID_data = data.matrix(SOLID_CCL)

# Use removeOutliers to remove noisy genes
HL_geneFilter = removeOutliers(HL_data, ensemble_ids)
SOLID_geneFilter = removeOutliers(SOLID_data, ensemble_ids)

# Now set the stage to remove noisy cancer cell lines
HL_data2 = data.matrix(HL_geneFilter@data)
SOLID_data2 = data.matrix(SOLID_geneFilter@data)

HL_data2 = t(HL_data2)
SOLID_data2 = t(SOLID_data2)

HL_allFilter = removeOutliers(HL_data2, HL_tissue)
SOLID_allFilter = removeOutliers(SOLID_data2, SOLID_tissue)
```

The final dataframe will be constructed here.
```{r}
# Construct the final dataframe
HL_final = t(data.matrix(HL_allFilter@data))
SOLID_final = t(data.matrix(SOLID_allFilter@data))
rownames(HL_final) = c(HL_geneFilter@id)
colnames(HL_final) = c(HL_allFilter@id)
rownames(SOLID_final) = c(SOLID_geneFilter@id)
colnames(SOLID_final) = c(SOLID_allFilter@id)
```

If we want to do a final sanity check, here's a code block that can make those plots.
```{r}

tmp = t(data.matrix(SOLID_final))
colnames(tmp) = NULL
rownames(tmp) = NULL

# Visualize cancer cell lines in 2D space
solid_pc_filtered = PCAtools::pca(tmp)
#PCAtools::screeplot(solid_pc_filtered)
#PCAtools::biplot(solid_pc_filtered, x="PC1", y="PC2", showLoadings=TRUE)
#PCAtools::pairsplot(solid_pc_filtered)
plot(solid_pc_filtered$rotated$PC1, solid_pc_filtered$rotated$PC2)


# Visualize genes in 2D space
tmp = data.matrix(SOLID_final)
colnames(tmp) = NULL
rownames(tmp) = NULL

solid_pc_filtered = PCAtools::pca(tmp)
plot(solid_pc_filtered$rotated$PC1, solid_pc_filtered$rotated$PC2)
```

### Batch Effect Correction using `ComBat-Seq`
Now we can use Combat-Seq to perform batch correction from our expression set. Specifically, we'll be correcting for tissue lineage relationships with the cleaned up dataset.

First, let's construct the `pheno` dataframe, a dataframe that contains

First let's construct the model matrix which contains the adjustment variables and the variable of interest.
```{r}
mod = model.matrix(~as.factor(tissue), data=pheno)
mod0 = model.matrix(~1, data=pheno)
```

Now let's compute the latent factors that need to be estimated. Note that this code will take awhile as it needs to perform several SVD operations.
```{r}
n.sv = num.sv(dat=Xcpm, mod=mod)
svobj = svaseq(Xcpm, mod, mod0, n.sv=n.sv)
```

We can actually get differentially expressed genes using a parametric F-test. Let's check this out!
```{r}
# Compute initial P and Q-values
tmp_pval = f.pvalue(data.matrix(Xfinal), mod, mod0)
tmp_qval = p.adjust(tmp_pval, method='BH')

# Create adjusted models
modSv = cbind(mod, svobj$sv)
mod0Sv = cbind(mod0, svobj$sv)

# Adjust p-values using Combat
combat_pvalues = f.pvalue(data.matrix(Xfinal), modSv, mod0Sv)
combat_qvalues = p.adjust(combat_pvalues, method='BH')
```

### Data Normalization 
Now let's take the log2 of the counts-per-million of the RNASeq counts.
```{r}
Xfinal = DGEList(Xfinal, 
               genes=genes_filtered,
               group=as.factor(tissue))
Xnorm = calcNormFactors(Xfinal)

#cutoff = 1
#drop = which(apply(cpm(Xnorm), 1, max) < cutoff)
#Xfilter = Xnorm[-drop, ] 
#dim(Xfilter) # number of genes left

lcpm = cpm(SOLID_final, log=TRUE)
```

### Perform *limma-voom* 
We'll save the results as an .rds file.
```{r}
# Construct an object for limma-voom
X = DGEList(counts=Xfinal, 
            genes=genes_filtered, 
            group=as.factor(tissue))
```

First, we'll need to calculate the variance weights using the voom function.
```{r}
y = voom(X, mod, plot=TRUE)
```

Okay, it looks like the variance stabilizes. Now let's fit the linear model using weighted least squares for each gene to compute some coefficients.

```{r}
design = model.matrix(~ adjvar)
theta = lmFit(object=y, design=design)
```

Now I need to estimate the contrast for each gene across different cell lines and smooth the standard errors using Empirical Bayes.
```{r}
for(i in ){
  
}
```

I can then extract differentially expressed genes
```{r}
DEG = topTable(tmp, sort.by="P", n=Inf)

```