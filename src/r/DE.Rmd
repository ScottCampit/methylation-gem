---
title: "Differential expression analysis"
author: "Scott Campit"
output: 
  html_notebook:
    toc: yes
---

## Summary
This notebook performs differential expression analysis for various transcriptomics datasets. 

**UPDATES: **

  * November 4, 2020: Added more stringent and robust differential expression analysis options.
  * Follow computational pipeline outlined in Yu, et al. (2019). Comprehensive transcriptomic analysis of cell lines as models of primary tumors across 22 tumor types. Nature communications, 10(1), 1-11.
  * Compute differentially expressed genes using both edgeR, DESeq2, and limma-voom
  * Take intersection of differentially expressed genes 
  
## 1. Load libraries
First we'll load some essential packages needed to run differential expression analysis.
```{r, warning=FALSE, message=FALSE}
# Bioinformatics libraries
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages(c("BiocManager", "edgeR", 
#                       "DESeq2", "limma", 
#                       "sva", "PCAtools"))

#install.packages("CePa", dependences=TRUE)
#BiocManager::install("Rgraphviz")
library(CePa)
library(edgeR)
library(DESeq2)
library(limma)
library(sva)
library(PCAtools)

# Data science libraries
#install.packages(c("tidyverse", "readr", "rrcov"))
library(tidyverse)
library(readr)
library(rrcov)

```

## 2. Perform data preprocessing

This code block performs essential data preprocessing for the cancer cell line encyclopedia data.

### Read in raw RNASeq counts

First, let's load the table with the raw RNASeq gene counts.
```{r}
# ACLX path
#readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"
readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_RNAseq_genes_counts_20180929.gct"

# Dell
#readpath = "D:\\Data\\RNASeq\\CCLE\\CCLE_934_TPM_EBI.tsv"

# Load data either as a TPM or gene counts. I'm doing this from scratch.
#ccle = read_delim(file=readpath, delim='\t')
ccle = read.gct(readpath)
```

Note that in the raw gene count data matrix, the rows are labeled by Ensembl IDs, while the columns have the syntax CELLLINE_TISSUE, separated by an underscore. I can keep the Ensembl gene IDs, but I need to extract the tissue type, as this is a covariate of interest.

Later on, I can add other covariates of interest using meta data from the CCLE.

### Aggregate duplicate cell line entries.
Note that some cell lines (columns) are duplicate entries. I need to aggregate them before moving on to additional preprocessing steps. 
```{r}
tmp = t(ccle)
agg_tmp = aggregate(tmp, by=list(rownames(tmp)), mean)
agg_tmp[, 2:length(agg_tmp)] = lapply(agg_tmp[, 2:length(agg_tmp)], as.integer)
agg_tmp = as.data.frame(agg_tmp)
ccle = t(agg_tmp)
ccle = as.data.frame(ccle)
ccle = ccle[-1, ]
```

Now that I have aggregated duplicate cell lines, I can construct the phenotype dataframe `pheno` that I will need for downstream data processing.

### Construct the `pheno` dataframe
First, we'll extract the name of the tumor tissue subtype and then store the data in a dataframe. This will be used to create the model and the null model when performing covariate and artifact correction.

```{r}
# Get data from the ccle dataframe
tmp = colnames(ccle)
tissue = word(string=tmp, start=2, end=-1, sep="_")
ccl = word(string=tmp, start=1, sep="_")

# Store into dataframe

```


```{r}
# Create a dataframe with phenotype data
pheno = data.frame("Tissue"=tissue)
row.names(pheno) = ccl

# Change the column names in ccle
colnames(ccle) = ccl

```

### Missing value imputation
Note that there are missing values, so we'll impute them with the minimum value in the dataset.
```{r}
min_impute = function(df){
  for (cols in colnames(df)) {
    if (cols %in% names(df[,sapply(df, is.numeric)])) {
      df = df %>% mutate(!!cols := replace(!!rlang::sym(cols),
                                           is.na(!!rlang::sym(cols)),
                                           min(!!rlang::sym(cols), na.rm=TRUE)))
    }
  }
  return(df)
}

ccle = min_impute(ccle)
```

Check for NaNs. It looks like there are none
```{r}
print(cat("Number of NaNs: ", sum(is.na(ccle))))
```

### Data Normalization 

Now let's calculate the normalization factors from limma and also remove low-expressed genes that may be skewing rPCA.
```{r}
gene_symbols = ccle[, 1]
tmp = data.matrix(ccle[, 2:ncol(ccle)])

# Construct an object for limma-voom
X = DGEList(counts=tmp, 
            genes=gene_symbols, 
            group = as.factor(tissue[2:length(tissue)]))

# Perform upper-quartile normalization
Xnorm = calcNormFactors(X)
Xcpm = cpm(Xnorm, log=TRUE, prior.count=1)

# Set cutoff
cutoff = 1
drop = which(apply(Xcpm, 1, max) < cutoff)
Xcpm_filtered = Xcpm[-drop,] 
genes_filtered = gene_symbols[-drop, 1]
```

### Remove outliers
We will first remove some outliers using Robust PCA. It combines two ideas to find outliers:
  1. Find projections with maximal dispersion using a grid search.
  2. Estimate the covariance using an idea similar to Hubert robust regression.

The publication that benchmarks several robust PCA algorithms and the classical PCA counterparts can be found here: Chen, X., Zhang, B., Wang, T., Bonni, A., & Zhao, G. (2020). Robust principal component analysis for accurate outlier sample detection in RNA-Seq data. BMC bioinformatics, 21(1), 1-20.

First let's compute PCs and visualize the data with classical PCA. There are totally some really bad data points 
```{r}
pc = PCAtools::pca(data.matrix(Xcpm_filtered[, 2:ncol(Xcpm_filtered)]))
PCAtools::screeplot(pc)
PCAtools::biplot(pc)
PCAtools::pairsplot(pc)
```

Then let's get the highly quality data we want with robust PCA
```{r}
# Generate a Robust Huber object
pc = PcaHubert(data.matrix(Xcpm_filtered))

# Get the outliers
Xfinal = Xcpm_filtered
Xfinal = Xfinal[pc@flag, ]
genes_filtered = genes_filtered[pc@flag, 1]
```

### Save the Principle Component Results
I should really save this variable, because it is pretty time consuming to generate this.
```{r}
# ACLX
savepath = "C:\\Users\\scott\\Analysis\\eGEM\\r\\PCA\\CCLE_Counts_rPCA.rds"
saveRDS(pc, savepath)
```

### Create Limma data object and save the results
We'll save the results as an .rds file.
```{r}
# Construct an object for limma-voom
X = DGEList(counts=Xfinal, genes=genes_filtered, group=as.factor(tissue[2:length(tissue)]))

# ACLX
savepath = "C:\\Users\\scott\\Analysis\\eGEM\\r\\PCA\\CCLE_limma_input.rds"
saveRDS(X, savepath)

# Windows

```

### Load normalized data
Only run this block if you need to re-load the data
```{r}
# ACLX
readpath = "C:\\Users\\scott\\Data\\RNASeq\\CCLE\\CCLE_limma_input.rds"
X = readRDS(file=readpath)

# Windows

```


### Batch correction 

**NOTE:** As of November 5, 2020, this code does not work in it's current state. I will try to fix this ASAP. Until then, the preceding code blocks will be hashed.

Now that I have this data, I should correct for sequencing platform differences using ComBat. I will treat each tissue as a covariate in this batch correction.

The data needs to be in a dataframe.
```{r}
#X = data.frame(Xcpm)
```

We'll create appropriate variables.
```{r}
#colnames(X) = ccl[2:length(ccl)]
#adjvar = as.factor(tissue[2:length(tissue)])
```

Now let's actually perform batch correction for each tissue.
```{r}
# Create model and null matrix
#mod = model.matrix(~adjvar, data=adjvar)
#mod0 = model.matrix(~1, data=adjvar)

# Estimate latent factors and estimate surrogate variables
#n.sv = num.sv(X, mod, method="leek")
#svobj = sva(X, mod, mod0, n.sv=n.sv)
```
Now we can get the parametric F-test p-values for each row in the data matrix, then calculate the Q values less than the significance threshold of 0.05.
```{r}
#modSv = cbind(mod, svobj$sv)
#mod0Sv = cbind(mod0, svobj$sv)
#pval = f.pvalue(X, modSv, mod0Sv)
#qval = p.adjust(pval, method="BH")
```

### Save batch corrected data


### Differential Expression Analysis
We'll now perform differential expression using three different platforms:
  1. *limma-voom*
  2. *edgeR*
  3. *DESeq2*
  
#### *limma-voom*
First, we'll need to calculate the variance weights.
```{r}
adjvar = as.factor(tissue[2:length(tissue)])
adjvar = interaction(adjvar)
mdl = model.matrix(~0 + adjvar)
y = voom(X, mdl, plot=TRUE)
```

Okay, it looks like the variance stabilizes. Now let's fit the linear model using weighted least squares for each gene to compute some coefficients.

```{r}
design = model.matrix(~ adjvar)
theta = lmFit(object=y, design=design)
```

Now I need to estimate the contrast for each gene across different cell lines and smooth the standard errors using Empirical Bayes.
```{r}
for(i in ){
  
}
```

I can then extract differentially expressed genes
```{r}
DEG = topTable(tmp, sort.by="P", n=Inf)

```